<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="content-language" content="en">
    <meta name="DC.Language" scheme="RFC1766" content="English">
    <meta name="distribution" content="global">
    <meta name="resource-type" content="document">

    <title>Rubik's Cube Robot</title>
    <link rel="stylesheet" href="resources/RubiksCubeRobot.css" type="text/css">
    <script src="resources/RubiksCubeRobot.js" type="text/javascript"></script>
    <link rel="stylesheet" href="resources/lejos-tutorial.css" type="text/css">
</head>

<body>
<!-- The Dr. Shahar Maoz Header-->
<div style="margin-left: 100px"><img style="width: 100%" src="./resources/title.PNG"></div>

<!------------------------ The side navigation bar ----------------------------->
<div class="sidenav">
    <img width="100" src="./resources/cube.png">
    <a href="#PageTitle">Cube Solving Robot</a>
    <a href="#description">System Description</a>
    <a href="#nxtRobot">NXT Robot</a>
    <a href="#devEnv">Dev Environment</a>
    <a href="#architecture">Project Architecture</a>
    <a href="#robotClass">Robot Class</a>
    <a href="#cubeClass">Cube Class</a>
    <a href="#algorithm">Solving Algorithm</a>
    <a href="#tests">Tests</a> 
    <a href="#userGuide">User Guide</a>
    <a href="#generalRemarks">General Remarks</a>
    <a href="#gallery">Gallery</a>
    <a href="javadoc/index.html">JavaDoc</a>
    <!-- A "Top" button to jump to the website beginning -->
    <button id="topBtn" title="Go back to top" onclick="topFunction()">Top<img align="top" width="18" src="./resources/up.png"></button>
</div>

<!------------------------- The Site Contents ---------------------------------->
<div class="contents">
    <table cellpadding="0" cellspacing="0" class="n2t1">
        <tbody>
        <td>
            <!-- CONTENT AREA --> <!-- CONTENT TITLE -->
            <div id="PageTitle">The Rubik's Cube Solving Robot</div>
            <p>The Robot is a MindCuber for LEGO MINDSTORMS NXT 2.0 which was designed for solving Rubik's cube
            <br>The Robot's NXT computer is able to run different kinds of cube solving algorithms written with Java
            <br>There's much to say on this amazing little Lego Robot,
                but a picture is worth a thousand words
                <br>and a <b>full Cube Solving video is worth a million...</b><img align="top" width="30" src="resources/cubeAnimation2.gif">
            </p>
            <div><iframe width="560" height="315" src="https://www.youtube.com/embed/YC9H22MIo5o" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div>
            <p>And for those of you who are still shocked by the first demo, here's another demo:</p>
            <div><iframe width="560" height="315" src="https://www.youtube.com/embed/WYyZaW3r1MA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div>
            <p>The next vedeo demonstrates a "Cross Pattern" cube solution:</p>
            <div><iframe width="560" height="315" src="https://www.youtube.com/embed/I49jcPHtw_A" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div>

            <a name="description"><h4 class="midTitle">System description</h4></a>
            <p>We now give an informal description of the robot and its tasks...</p>
            <a name="requirements"><h5>Requirements</h5></a>
            <ol>
                <TODO>TODO...</TODO>
            </ol>
            <a name="assumptions"><h5>Assumptions</h5></a>
            <ol>
                <TODO>TODO...</TODO>
            </ol>

            <a name="nxtRobot"></a>
            <h4 class="midTitle">The NXT Robot</h4>
            <img width="200" src="./resources/robot.jpg"><br>
            <p>The robot is built from a LEGO® MINDSTORMS® NXT 2.0 set designed to solve the Rubik's Cube®
                <br>The building instructions are available <a href="http://mindcuber.com/mindcuber/mindcuber.html">here</a></p>

            <a name="devEnv"><h4 class="midTitle">The Development Environment</h4></a>
                <p>The project built using LeJOS Java libraries
                <a name="prerequisites"><h5>Prerequisites</h5></a>
                    <ul>
                        <li><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html">Java SE Development Kit 7 - 32 bit</a></li>
                        <li><a href="https://www.lego.com/en-us/mindstorms/downloads/nxt-software-download">LEGO® MINDSTORMS® NXT 2.0</a></li>
                        <li><a href="http://www.lejos.org/nxj-downloads.php">leJOS NXJ</a></li>
                        <li><a href="http://www.eclipse.org/downloads/eclipse-packages/">Eclipse IDE for Java Developers - 32 bit</a></li>
                        <li><a href="https://lejos.sourceforge.io/nxt/nxj/tutorial/Preliminaries/UsingEclipse.htm">leJOS NXJ Plug-in for Eclipse</a></li>
                    </ul>
                
                <a name="buildInst"><h5>Build Instructions</h5></a><p>
                        First, build the NXT project and upload it to the brick using leJOS NXJ Plug-in in Eclipse.
                        <br>Only then build the PC project and run it. Upon running it will automaticlly connect to the NXT.
            
            <a name="architecture"></a>
                <h4 class="midTitle">Project Architecture</h4><p>                
                    Due to the fact that the color sensor read method (RGB mode) is not implemented in the PC mode of 
                    LeJOS, and on the other hand the algorithm cannot run in NXT mode due to insufficient memory,
                    we devided the project to two applications.                    
                    <br>We've implemented a communication between the PC application that's running the algorithm and 
                    the NXT application that performs all of the robot's operations including the unimplemented 
                    color sensor read operation.
                
                    <p>The Project is divided into the three following sub-projects:
                
                        <a name="nxtProj"><h5>NXT Project</h5></a><p>
                            Running simple program waiting for commands from the PC application.
                            
                        <a name="pcProj"><h5>PC Project</h5></a><p>
                            Main program of the project, the PC application.
                            <p>The PC application responsible for the user interface, test methods, calibration methods and solving the cube.
                            <p>This project is divided into the following main modules:</p>
                                <ul>
                                    <li>The Algorithm: receives the cube representation and calculates the required solving steps (to be
                                        executed by the robot)
                                    </li>
                                    <li>The Cube: creating a Java class which holds the cube’s representation and relevant data (passed as
                                        an input to the algorithm)
                                    </li>
                                    <li>The Robot: creating our own friendly API for scanning and manipulating the cube</li>
                                </ul>
                        <a name="utProj"><h5>Unit Test Project</h5></a><p>
                            This project contains all the projects' unit testing
                    
            <a name="robotClass"></a>
                    <h4 class="midTitle">The Robot Class</h4>
                    
                    
                    <a name="actions"><h5>Actions</h5></a>
                    
                            <p>The Robot supports the following actions for the Cube's usage:</p>
                            <ul>
                                <li> Robot.flipCube(...)  &nbsp; &nbsp;  // performs 0, 1 or 2 Cube BackFlips as requested</li>
                                <li> Robot.rotateCube(...)&nbsp;         // performs Full Cube Rotations to the LEFT, RIGHT, or 180 degrees</li>
                                <li> Robot.turnFace(...)  &nbsp; &nbsp;  // Specific Cube Face Rotation to the LEFT, RIGHT, or 180 degrees</li>
                                <li> Robot.scanFace(...)  &nbsp; &nbsp;  // scans all colors in the given cube's face</li>
                                <li> More operations...</li>
                            </ul>

                            <p>Following is the 'flipCube' method, which flips the cube according to the flipMethod enum parameter -  SINGLE(1), DOUBLE(2), NONE(0):
                            <pre class="CodeBox"><code>
/**
 * Flip the cube
 *
 * @param method Flip method
 * @see FlipMethod
 */
public static void flipCube(FlipMethod method) {
    for (int i = 0; i < method.getFlips(); i++) {
        Arm.motor.rotateTo(ARM_POSITION_HOLD + ARM_POSITION_HOLD_EXTRA);
        Arm.motor.rotateTo(ARM_POSITION_HOLD);
        delayMillisec(ARM_FLIP_DELAY_MS);
        Arm.motor.rotateTo(ARM_POSITION_TACKLE);
        Arm.motor.rotateTo(ARM_POSITION_HOLD);
    }	
}
                            </code></pre></p>


                            <p>Following is the 'turnFace' method,
                                which turns the currently facing down face selected face according to the turning direction argument:
                            <pre class="CodeBox"><code>
/**
 * Rotate the face currently facing down
 *
 * @param direction Turning direction
 * @see Direction
 */
public static void turnFace(Direction direction) {
    Arm.motor.rotateTo(ARM_POSITION_HOLD);
    int extraRotation = direction.getDegree() > 0 ? 
                                        TRAY_MOTOR_EXTRA_ROTATION : (-TRAY_MOTOR_EXTRA_ROTATION);
    Tray.motor.rotate((direction.getDegree() + extraRotation) * TRAY_MOTOR_ROTATION_FACTOR);
    Tray.motor.rotate((-extraRotation) * TRAY_MOTOR_ROTATION_FACTOR);
}
                            </code></pre></p>

                            <p>Following is the 'rotateCube' method,
                                which Rotates the entire cube according to the direction argument:
                            <pre class="CodeBox" style="width: 400px"><code>
/**
 * Rotate entire cube
 *
 * @param direction Rotate direction
 * @see Direction
 */
public static void rotateCube(Direction direction) {
    if (direction != Direction.NONE) {
        Arm.release();
        Tray.rotate(direction.getDegree());
    }
}
                            </code></pre></p>



                    <a name="colorScan"><h5>Color Scan</h5></a><p>
                    
                            The NXT's color sensor is problematic and unrelaiable, so we needed to be creative in order to scan the cube.
                            
                            <p>Those are the phases of our color scaning development:
                            <ol>
                                <li>
                                        We've started with the simple ReadColorId method supplied with the LeJOS API.
                                        We've understanded very quick that this method cannot different at all between red and orange colors 
                                        so it was useless for us.
                                
                                <li>
                                        Later on we've used the RGB representation reading of each color.
                                        In order to utilize those readings, we've added calibration method that saves the RGB read of each color
                                        before starting solving the cube.
                                        Then, when scanning the face and read RGB of some color, we've searched for the closest color with
                                        the calibrated data we saved before.
                                        But... we still had problems with red and orange colors!
                                        
                                <li>
                                        Our next step was to develop color corrector method.
                                        Since each of the cube's corners are deterministic, we can correct any red and orange mistakes in the cube's corners by looking at thier neighbors.
                                        More about it can be learned below.
                                        And yet it wasn't enough! We were on 70% success rate because we still had problems with red and orange colors that are not on the corners...
                                 
                                <li>
                                        SHIFT DELETE.
                                        We needed to redesign the color reading method, we've decided to calculate the colors relatively. 
                                        First scan RGB colors of the whole cube. 
                                        Then, filter out all the white readings by thier destination to the calibrated data (similar to step 2 above). 
                                        Last, converting the readings to HSV format, and sorting them by thier hue value.
                                        The first 9 lowest hue values are defined as red, the next 9 defined as orange and cetera... 
                                        Now, under good lighting conditions we're on 99% success rate!                                        
                            </ol>

                            <p>Following is the method responsible for scanning single cube's face
                            <pre class="CodeBox"><code>
/**
 * Scan cube's face
 * 
 * @param allColors List of all scanned colors 
 * @param orientation Current cube orientation
 * @see Orientation
 */
public static void scanFace(ArrayList<RawColor> allColors, Orientation orientation) {
    int coordinate, row, col;
    int[] rgb;
    SensorLocation location;
     
    Arm.release();
    for (coordinate = 0; coordinate < 8; coordinate++) {
        row = COORDINATE_SCAN_ORDER[coordinate][0];
        col = COORDINATE_SCAN_ORDER[coordinate][1];
        location = coordinate % 2 == 0 ? SensorLocation.ALLIGN : SensorLocation.CORNER;
        ColorDetector.setMotorLocation(location);
        rgb = ColorDetector.sensor.readColorRgb(SENSOR_NUMBER_OF_SAMPLES);
        RawColor rawColor = new RawColor(orientation, row, col, rgb);
        allColors.add(rawColor);
        Tray.motor.rotate(TRAY_SCAN_STEP_DEGREE);
    }

    row = COORDINATE_SCAN_ORDER[coordinate][0];
    col = COORDINATE_SCAN_ORDER[coordinate][1];
    ColorDetector.setMotorLocation(SensorLocation.CENTER);
    rgb = ColorDetector.sensor.readColorRgb(SENSOR_NUMBER_OF_SAMPLES);
    RawColor rawColor = new RawColor(orientation, row, col, rgb);
    allColors.add(rawColor);
    ColorDetector.motor.rotateTo(0);
}
                            </code></pre></p>
                    
                            <p>Following is the method responsible for setting the cube's colors given
                            the raw readings of all the colors:
                            <pre class="CodeBox" style="width: 500px"><code>
/**
 * Place all scanned colors on the cube, fix red/orange corners
 * and print result to logger 
 * 
 * @param allColors All scanned colors
 */
private void calcAndSetColors(ArrayList<RawColor> allColors) {
    setWhitesByDistance(allColors);
    setNonWhitesByHue(allColors);
    ColorCorrector.fixCorners(faces);
    printCubeColorsToLogger();
}
                            </code></pre></p>
                    
                    
                    <a name="colorCorrector"><h5>The Color Corrector Class</h5></a><p>
                        <code><b>public class ColorCorrector</b></code><br>
                        An essential component in the process of solving a cube by robot,
                        is achieving a reliable image of the cube's colors. <br>
                        The ColorCorrector class is intended to do exactly that! It corrects color scanning errors
                        (which often occur due to the sensitive and unideal color sensors)
                        and provides a highly reliable description of the cube's colors (to be safely used by the algorithm).<br>
                        The NXT's color sensor has difficulties to distinguish between Red and Orange colors. <br>
                        Since we are able to determine the colors at each of the cube's corners by it's neighbors,
                        we can detect and correct any Red/Orange mix up at the corners.
                        This is how the class represents the corner:
                    <pre>
                             +--------+--------+
                             |        |        |
                             | corner | right  |
                             |        |        |
                             |        |        |
                             +--------+--------+
                             |        |
                             |  left  |
                             |        |
                             |        |
                             +--------+
                    </pre>
                    Whereas each of the squares above belong to another cube's face.
                    </p>
        <p>The following enumeration represent all corners of cube's face:</p>
        <pre class="CodeBox" style="width: 400px"><code>
private enum Corner {
    UPPER_LEFT(0, 0, 0),
    UPPER_RIGHT(1, 0, 2),
    LOWER_LEFT(2, 2, 0),
    LOWER_RIGHT(3, 2, 2);
}
        </code></pre>
                    <pre>
                          +--------+--------+--------+
                          |        |        |        |
                          | UPPER  |        | UPPER  |
                          | LEFT   |        | RIGHT  |
                          |        |        |        |
                          +--------+--------+--------+
                          |        |        |        |
                          |        |        |        |
                          |        |        |        |
                          |        |        |        |
                          +--------+--------+--------+
                          |        |        |        |
                          | LOWER  |        | LOWER  |
                          | LEFT   |        | RIGHT  |
                          |        |        |        |
                          +--------+--------+--------+
                    </pre>
                    <p>
                        The following 'fixCorners' method is responsible for the fix routine:<br>
                        Iterates over all the cube's Red/Orange corners and fix them according to their neighbors.
                    </p>
        <pre class="CodeBox"><code>
static void fixCorners(Face[] faces) {
    boolean cubeFixed = false;
    for (Orientation orientation : Orientation.values()) {
        Face face = faces[orientation.getValue()];

        for (Corner corner : Corner.values()) {
            if (face.getColor(corner.row, corner.col) == Colors.RED
                            || face.getColor(corner.row, corner.col) == Colors.ORANGE) {
                Colors left = getCornerLeftColor(faces, face, corner);
                Colors right = getCornerRightColor(faces, face, corner);

                for (Colors[] cornerColors : RED_ORANGE_CORNERS) {
                    if (left == cornerColors[0] && right == cornerColors[2]) {
                        Colors scannedColor = face.getColor(corner.row, corner.col);
                        Colors cornerColor = cornerColors[1];
                        if (scannedColor != cornerColor) {
                            face.setColor(corner.row, corner.col, cornerColor);
                        }
                    }
                }
            }
        }
    }
}
        </code></pre>

                            <a name="nxtComm"><h5>NXT Communication</h5></a><p>
                            As mentioned before, we needed to implement communication between the PC and NXT applications.
                            <br>We've simply wrapped all of the motors and sensors operations in the PC project, and send appropriate
                            command to the NXT application, that parsed the command and act upon it.

                            <p>For example, this is the implementation of the <code>rotateTo</code> method in the PC project:
                            <pre class="CodeBox" style="width: 840px"><code>
/**
 * Rotate motor to specified location
 * @param limitAngle Degrees limit to rotate
 */
public void rotateTo(int limitAngle) {
    NxtCommand.sendCommand(NxtOperation.OPERATION_TYPE_MOTOR, id, NxtOperation.OPERATION_ID_ROTATE_TO, limitAngle, 0);		
}
                            </code></pre></p>
                            
                            <p>This data sent as bytes to the NXT application. Upon receiveing the raw bytes data,
                            the NXT application interpretes and act upon it:
                            <pre class="CodeBox" style="width: 600px"><code>
/**
 * Run the main loop waiting for command from PC
 * This function exits upon pressing the ESC button on the NXT
 */
private static void runCommandListener() {

...

        for (;;) {
            try {
                if ((inputBufferLength = in.read(inputBuffer)) > 0) {
                    if (inputBufferLength != 7) {
                        printToLcd("Unknown data", "received", 10000);
                        continue;
                    }
                    printToLcd("Command recieved:", bytesToHex(inputBuffer), 0);
                    byte operationType = inputBuffer[0];
                    int port = (int) inputBuffer[1];
                    byte operationId = inputBuffer[2];

                    int argument = 0;
                    argument |= (((int) inputBuffer[3]) & 0x000000FF) << 24;
                    argument |= (((int) inputBuffer[4]) & 0x000000FF) << 16;
                    argument |= (((int) inputBuffer[5]) & 0x000000FF) << 8;
                    argument |= (((int) inputBuffer[6]) & 0x000000FF) << 0;

                    if (operationType == OPERATION_TYPE_MOTOR) {
                        switch (operationId) {
                        case OPERATION_ID_ROTATE:
                            motors[port].rotate(argument);
                            break;
                        case OPERATION_ID_ROTATE_TO:
                            motors[port].rotateTo(argument);
                            break;
                            
...                            
                            </code></pre></p>                     
                            
                            
            <a name="cubeClass"></a>
            <h4 class="midTitle">The Cube Class</h4>
            <img id="cubeAnim" style="padding-right: 200px" align="right" src="resources/cubeAnimation.gif">
            <p>
                Provides a smart and compact Cube object which holds the cube’s data: Faces, colors and
                orientations<br>
                Managing changes in the cube’s orientations caused by rotations and flips (performed by the robot)
            </p>

            <a name="middleMan"><h5>The Middle Man...</h5></a>
            <p>
                The Cube.java class acts as the "middle man" between the Robot and the Algorithm:
                <br>The main.java program creates the Cube object and passes it on to the Algorithm.
                <br>The algorithm utilizes the Cube's functionality to read the Cube's colors and manipulate the Cube's
                faces, while the Cube transforms these requests to Robot actions.
                <br>The advantage is the Cube's ability to keep track of the changing orientations whenever the Robot
                rotates and flips the Cube.
            </p>

            <a name="interfaces"><h5>Public Interfaces</h5></a>
            <p>The following 'ICube' and 'IFace' interfaces expose the public methods of the cube,
            <br>which provide a safe and efficient way to manipulate the cube while tracking state changes.</p>
            <p>The public methods were carefully planned to expose only the exact functionality required for the client (namely
                the Algorithm class)
                <br>while keeping things 'simple' as possible.</p>
<p>The IFace interface, which represents each of the six cube faces:
<pre class="CodeBox"><code>
public interface IFace {
   /*
    * Returns the color of a position (row, col) in a face
    */
    public Colors getColor(int i, int j);

    /*
     * Represents a turn of the face in a desired direction.
     * It uses the dynamic orientation and the actions table to derive
     * the number of flips and rotation needed in order to bring this face to the bottom.
     * after this face is brought to the bottom, it is turn in the desired direction.
     * @param direction The direction that the face should turn
     */
    public void turn(Direction direction);
}
</code></pre></p>
<p>The ICube interface, which represents the entire cube:
<pre class="CodeBox"><code>
public interface ICube {
/*
 * returns the face which is currently in the orientation requested (UP, DOWN, LEFT, ...)
 */
IFace getFace(Orientation orientation);

/*
 * Scan and set the cube colors.
 * The method is first to scan all of the cube's colors in RGB mode,
 * and calculate their HSV representation as well as their distance from
 * the calibrated white RGB.
 * Second, sort all the colors by their white distance (since white doesn't have
 * meaningful Hue value), and place them on the cube.
 * Last, sort all the colors by their Hue value and place them on the cube
 * according to their Hue value.
 */
void setColors();

}
</code></pre></p>


            <a name="representation"><h5>Cube Representation</h5></a>
            <p>
                The Cube object is the representation of the Rubik's Cube as provided to the Algorithm class
                for calculating the required steps to reach a full solution.<br>
                A Cube object is consisted of six Face objects, where each one provides the functionality of a 'face turn'
                as well as the option of reading all face's colors.<br>
                One of the interesting challenges regarding the manipulations of the cube,
                arises from the fact that the robot can only rotate the bottom cube's face (placed on it's tray),
                while the algorithm may instruct to turn any of the cube's faces at each step.
                As consequence, the Robot often flips and rotates the whole cube in order to position the selected face
                as the bottom face.
                To bridge this gap, we let the algorithm act as if the cube is static (initial orientations never change),
                while translating each 'static' face orientation selection (Up, Down, etc.) to the 'dynamic' actual
                orientation of the selected face.<br>
                This process is implemented efficiently by the Cube class, by using an Orientations matrix and an Actions array
                which help keeping track of the 'dynamic' orientation of each of the cube's faces.
            </p>

            <a name="orientations"><h5>Cube Orientations</h5></a>
            <br><img width="200" src="./resources/rubikFlat.png"><br>

<p>The Orientations Matrix:
    <br> Following every rotation and flip of the cube executed by the robot, the cube's orientations change (i.e. 'UP' face may become 'DOWN', etc.)
    <br> The Orientations Matrix is a static matrix which represent the new position of every face
    <br> once any face is set to be the bottom face ('DOWN' orientation).
    <br> The faces are listed in the following order: 0 = Up, 1 = Right, 2 = Front, 3 = Down, 4 = Left, 5 = Back
    <br> <u>Example of use:</u>
    <br> Suppose we need to set the current 'FRONT' face to be the bottom ('DOWN') face,
    <br> in order to know how this action affects the other faces, we should go to the 2nd row of
    <br> the matrix (as listed above: 2 = FRONT), and we will find the new positions of the other faces:
    <br> position 0 has the value L -> indicates that the UP face (0 = UP) becomes the LEFT face.
    <br> position 1 has the value F -> indicates that the RIGHT face (1 = RIGHT) becomes the FRONT face, etc.
    <br> in conclusion we got these transforms: U->L , R->F , F->D , D->R, L->B , B->U
    <br> this matrix help us to determine the positions of the faces in any transition.
<pre class="CodeBox"><code>
private static final Orientation[][] ORIENTATION_MAT = {
{ Orientation.D, Orientation.L, Orientation.F, Orientation.U, Orientation.R, Orientation.B },
{ Orientation.L, Orientation.D, Orientation.B, Orientation.R, Orientation.U, Orientation.F },
{ Orientation.L, Orientation.F, Orientation.D, Orientation.R, Orientation.B, Orientation.U },
{ Orientation.U, Orientation.R, Orientation.F, Orientation.D, Orientation.L, Orientation.B },
{ Orientation.L, Orientation.U, Orientation.F, Orientation.R, Orientation.D, Orientation.B },
{ Orientation.L, Orientation.B, Orientation.U, Orientation.R, Orientation.F, Orientation.D } };
</code></pre></p>

            <p>
                Thanks to the 'Orientations Matrix' the routine of updating the new orientations of the faces after
                a transition of the cube, becomes a simple quick task -
                <br>The following method receives the current orientation of the face that was just set to the bottom,
                and performs required orientations updates to all six faces:
<pre class="CodeBox"><code>
void updateOrientations(Orientation orientation) {
Orientation[] newOrientations = ORIENTATION_MAT[orientation.getValue()];
    for (int i = 0; i < 6; i++) {
        faces[i].dynamicOrientation = newOrientations[faces[i].dynamicOrientation.getValue()];
    }
}
</code></pre></p>

            <p>The Action class, holds the required cube flips and turns
    to set a selected face as the bottom face:
<pre class="CodeBox"><code>
public class Action {

    public FlipMethod flips;
    public Direction direction;

    public Action(FlipMethod flips, Direction direction) {
    this.flips = flips;
    this.direction = direction;
    }
}
</code></pre></p>

<p>The 'Actions' Array:<br>
    specifies the flips and rotations that the robot should execute on the cube,
    to set the selected face as the bottom face (the only face that can be turned):
    <br>For instance, in order to turn the 'UP' face by 90 degrees clockwise, the Robot must first flip the cube twice
    to set the 'UP' face as the bottom, and then turn the face by 90 degrees counterclockwise.
    <br> Another example: in order to set the FRONT face as the bottom,
    the Robot should rotate the cube left and then perform a flip.
    <br>This action is stored on the actions array at position 2 (since 2 = FRONT): {FlipMethod.SINGLE, Direction.LEFT}
<pre class="CodeBox"><code>
actions[Orientation.U.getValue()] = new Action(FlipMethod.DOUBLE, Direction.NONE);
actions[Orientation.D.getValue()] = new Action(FlipMethod.NONE, Direction.NONE);
actions[Orientation.F.getValue()] = new Action(FlipMethod.SINGLE, Direction.LEFT);
actions[Orientation.B.getValue()] = new Action(FlipMethod.SINGLE, Direction.RIGHT);
actions[Orientation.R.getValue()] = new Action(FlipMethod.SINGLE, Direction.MIRROR);
actions[Orientation.L.getValue()] = new Action(FlipMethod.SINGLE, Direction.NONE);
</code></pre></p>



            <a name="algorithm"></a>
            <h4 class="midTitle">The Solving Algorithm</h4>
            <a name="choosingAlgo"><h5>Choosing the algorithm</h5></a>
            <TODO>TODO...</TODO>
            <p>Present the considerations that led to the two-phase algorithm</p>
            <p>Following our research on Rubik’s cube solving algorithms, we chose the following two-phase
                algorithm.</p>
            <a name="twoPhaseAlgo"><h5>2-Phase Algorithm</h5></a>
			<img id="imgHerbertKociemba" src="https://www.speedsolving.com/interviews/interview-herbertk.jpg">
            <p>
				We are using the two-phase algorithm, introduced by Herbert Kociemba in 1991-1992.
				The problem of solving the cube is translated into a shortest path in a graph problem, where the nodes are the different states of the cube,
				and there is an edge between two nodes if one state can be reached from the other by turning one face of the cube.
				Exploring and understanding the algorithm was one of the major parts of our project, and we believe it was quite educational (and most definitely fun :)).
            </p>
            <a name="solution"><h5>Searching For Solution</h5></a>
            <p>Searching for the solution is done in two phases:</p>
            <ol>
                <li>The algorithm first tries to find a path from cube’s initial state to one of the states that can be reached
                    from a solved cube using only the following moves: U, D, R2, L2 F2, B2.
                </li>
                <li>Once we found a path, the algorithm tries to find a path from the current state to the solved cube,
                    using only the moves mentioned above.
                </li>
            </ol>
            <p>
                The path search in the graph is done using the IDA* algorithm. Finding a shortest path in a graph can be
                done using a BFS-like tree search, but it requires a lot of memory. Using DFS-like tree search will help
                us finding a path, but not the shortest one. Therefore, the two-phase algorithm uses an iterative
                deepening search. Iterative deepening (ID) means a DFS search is performed iteratively for a growing
                tree depth. The search uses a heuristic function to stop searching in a specific branch when the
                solution cannot be found with the given state and depth. The heuristic function gives a lower bound on
                the number of moves required to reach from a state to the goal state.
            </p>
            <a name="algoRep"><h5>Cube Representation</h5></a>
            <p>
                Cube is represented in 3 levels:
				<br><b> Facelets Level </b> - cube is represented by an 54 entries array. Each entry is one of the 6 possibe colors of cube faces.
				This is the initial, most simple representation.
				<br><b> Cubie Level </b> - cube is represented by it's coreners and edges permutations and orientations, compared to a solved cube.
				This representation tells us where to move and how to rotate each corner and where to move and how to flip each edge in order to reach a given cube from a solved cube.
				Using this representation, we can define the inverse cube of a cube, which is a cube that if we perform the set of moves created it from a solved cube on the original cube, we reach the solved cube.
				We can also define a multiplication of two cubes. You can think of multiplying cube A by cube B like taking a set of moves that transform a solved cube into B cube and perform it on A.
				<br><b> Coordinate Level </b> - cube is represented using a set of coordinates driven from it's corners and edges permutations and orientations compared to a solve cube.
				The set of coordinates is not the same in both phases. This set of coordinates defines us the state of the cube, which is used during the search algorithm.
            </p>
			<p>For more information regarding the two-phase algorithm, please refer to Kociemba’s site: <a href="http://kociemba.org/cube.htm">http://kociemba.org/cube.htm</a></p>
            <a name="implementation"><h5>The Implementation</h5></a>
            <p>
                Our implementation is based on Kociemba’s implementation for this algorithm, which he published in his site.
                It implements the two-phase algorithm in a simple form, and does not use symmetry for better performance.
				Moreover, the implementation does not find the shortest solution.
                It finds a short solution for the first phase, and then tries to find a short solution from current state
                to the solved cube, so the combination of the two is not necessarily the shortest solution.
            </p>

            <a name="modifications"><h5>Our Modifications</h5></a>
            <p>We added the ability to select a pattern, so that preforming the set of moves returned by the
                algorithm will produce a cube with the selected pattern.
                To allow the pattern ability, we calculate the inverse cube of the pattern, multiply it by the given
                cube and then find a solution for the resulted cube.
                The algorithm finds a solution for the resulted cube, which is also a set
                of moves to create its reverse cube from a solved cube. This reverse cube is the multiplication of the
                reverse of the original cube and the pattern, so applying the resulted set of moves on the cube brings
                us from the initial cube to a solved cube and then to the patterned cube (this is not done one after the
                other, this is just an easier way to understand what happens).
            </p>

            <a name="tests"></a>
            
                    <a name="unitTsts"><h5>Unit Tests</h5></a><p>
                    Since most of our logic in the project containd in the algorithm module, we've
                    put our best efforts testing it, and indeed we've reached 96.8% coverage rate!
                    <br>In addition we developed additional unit testing for the cube module.
                    <p>Since the robot module is mostly an API we've decided to test it physically
                    with brute force tests.
            
                    <a name="intgTest"><h5>Integration Tests</h5></a><p>
                    To check the robot reliability we've developed over-night test that performs 100
                    cube solving operations and validate the cube after each operation.
                    We've reached the following results:
                    <TODO> RESULTS </TODO>
            
            <a name="userGuide"></a>
            <h4 class="midTitle">User Guide</h4><p>
            
                    <a name="pcApp"><h5>PC Application</h5></a><p>
                    <p><img  src="./resources/mainmenu.jpg"><p>

                        <ul>
                            <li><b>Solve cube:</b>
                                    <br>Use this option after completing necessary calibration steps for solving the cube
                            </li><p>
                            
                            <li><b>Tests:</b>
                                <p><img  src="./resources/testsmenu.jpg"><p>
                                This menu contains all of the robot's tests recommended to run to validate all robot's operations:
                                <ul>
                                        <li>Brute force - performs random robot's operations</li>
                                        <li>Read color - read current color and print result to logger</li>
                                        <li>Flip cube - perfors cube flipping operations</li>
                                </ul>
                            </li><p>
                            
                            <li><b>Calibration:</b>
                                <p><img  src="./resources/calibrationmenu.jpg"><p>
                                This menu contains all of the robot's calibration routines:
                                <ul>
                                        <li>Color sensor - calibrate white color reading, place white color below the sensor and press <b>Enter</b></li>
                                        <li>Color motor - calibrate the color sensor motor. Follow the instructions of the program to calibrate the color sensor to it's three optional positions. Use the <b><</b> and <b>></b> buttons to rotate the motor</li>
                                        <li>Cube tray - calibrate the cube's tray motor. Use the <b><</b> and <b>></b> buttons to rotate the tray to be aligned</li>
                                        <li>Proximity - read the current proximity sensor data</li>
                                        <li>
                                                Color light - read the current background light. Use it to make sure the lighting condition of the room are suitable for the color sensor:<p>
                                                <ul>
                                                        <li>Light okay:<p><img  src="./resources/background_ok.jpg"><p></li>
                                                        <li>Light too strong<p><img  src="./resources/background_not.jpg"><p></li>
                                                </ul>
                                        </li>
                                </ul>
                                
                            </li><p>
                            
                            <li><b>Pattern:</b>
                                <p><img  src="./resources/patternmenu.jpg"><p>
                                This menu contains additional patterns for cube solving:
                                <ul>
                                        <li>Plus minus</li>
                                        <li>4 cross</li>
                                        <li>Cube cube</li>
                                        <li>Cube cube cube</li>
                                </ul>
                            </li><p>
                            
                        </ul>
                                

            <a name="generalRemarks"></a>
            <h4 class="midTitle">General Remarks</h4>
            <TODO>TODO...</TODO>

            <a name="gallery"></a>
            <h4 class="midTitle">Gallery</h4>
            <TODO>TODO...</TODO>
            <br><br><img width="400" src="./resources/RubiksVariations.jpg"><br>

        </td>
        </tr>
        </tbody>
    </table>
</div>
</body>
</html>
