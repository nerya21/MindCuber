<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="content-language" content="en">
    <meta name="DC.Language" scheme="RFC1766" content="English">
    <meta name="distribution" content="global">
    <meta name="resource-type" content="document">

    <title>Rubik's Cube Robot</title>
    <link rel="stylesheet" href="resources/RubiksCubeRobot.css" type="text/css">
    <script src="resources/RubiksCubeRobot.js" type="text/javascript"></script>
    <link rel="stylesheet" href="resources/lejos-tutorial.css" type="text/css">
</head>

<body>
<!-- The Dr. Shahar Maoz Header-->
<div style="margin-left: 100px"><img style="width: 100%" src="./resources/title.PNG"></div>

<!------------------------ The side navigation bar ----------------------------->
<div class="sidenav">
    <img width="100" src="./resources/cube.png">
    <a href="#PageTitle">Cube Solving Robot</a>
    <a href="#nxtRobot">NXT Robot</a>
    <a href="#devEnv">Dev Environment</a>
    <a href="#architecture">Project Architecture</a>
    <a href="#reqAndAssump">Requirements & Assumptions</a>
    <a href="#robotClass">Robot Class</a>
    <a href="#cubeClass">Cube Class</a>
    <a href="#algorithm">Solving Algorithm</a>
    <a href="#tests">Tests</a> 
    <a href="#userGuide">User Guide</a>
    <a href="#generalRemarks">General Remarks</a>
    <a href="#gallery">Gallery</a>
    <a href="https://github.com/nerya21/MindCuber">Repository</a>
    <a href="javadoc/index.html">JavaDoc</a>
    <!-- A "Top" button to jump to the website beginning -->
    <button id="topBtn" title="Go back to top" onclick="topFunction()">Top<img align="top" width="18" src="./resources/up.png"></button>
</div>

<!------------------------- The Site Contents ---------------------------------->
<div class="contents">
    <table cellpadding="0" cellspacing="0" class="n2t1">
        <tbody>
        <td>
            <!-- CONTENT AREA --> <!-- CONTENT TITLE -->
            <div id="PageTitle">MindCuber - The Rubik's Cube Solving Robot</div>
            <p>
                This project deals with the development of a Rubik’s cube solving robot,
                <br>based on a LEGO® MINDSTORMS® NXT 2.0 kit Robot designed for this purpose.
                <br>The robot is capable of running different kinds of cube solving algorithms written with Java.
            </p>
            <p>
                There's much more to say on this amazing little Lego Robot, but a picture is worth a thousand words
                <br>and a <b>full cube solving video is worth a million...</b><img align="top" width="30" src="resources/cubeAnimation2.gif">
            </p>
            <div><iframe width="560" height="315" src="https://www.youtube.com/embed/YC9H22MIo5o" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div>
            <p>And for those of you who are still shocked by the first demo, here's another demo:</p>
            <div><iframe width="560" height="315" src="https://www.youtube.com/embed/WYyZaW3r1MA" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div>
            <p>The next video demonstrates a "Cross Pattern" cube solution:</p>
            <div><iframe width="560" height="315" src="https://www.youtube.com/embed/I49jcPHtw_A" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe></div>

            <a name="nxtRobot"></a>
            <h4 class="midTitle">The NXT Robot</h4>
            <img width="200" src="./resources/robot.jpg"><br>
            <p>The robot is built from a LEGO® MINDSTORMS® NXT 2.0 set designed to solve the Rubik's Cube®
                <br>The building instructions are available <a href="http://mindcuber.com/mindcuber/mindcuber.html">here.</a>
            <br>
                The NXT robot consists of three motors: one for the arm that performs flips,
                the other for the rotation of the tray on which the cube is placed
                and the third for the color sensor to be drawn to each of the sides in the color scanning phase
                <br>The robot also has two sensors: the first is responsible for color scanning and
                the other is a proximity sensor that identifies the distance from the cube.
            </p>

            <a name="devEnv"><h4 class="midTitle">The Development Environment</h4></a>
            <p>The project built using LeJOS Java libraries</p>
                <a name="prerequisites"><h5>Prerequisites</h5></a>
            <ul>
                <li><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html">Java
                        SE Development Kit 7 - 32 bit</a></li>
                <li><a href="https://www.lego.com/en-us/mindstorms/downloads/nxt-software-download">LEGO® MINDSTORMS®
                    NXT 2.0</a></li>
                <li><a href="http://www.lejos.org/nxj-downloads.php">leJOS NXJ</a></li>
                <li><a href="http://www.eclipse.org/downloads/eclipse-packages/">Eclipse IDE for Java Developers - 32
                    bit</a></li>
                <li><a href="https://lejos.sourceforge.io/nxt/nxj/tutorial/Preliminaries/UsingEclipse.htm">leJOS NXJ
                    Plug-in for Eclipse</a></li>
            </ul>

            <a name="buildInst"><h5>Build Instructions</h5></a>
            <p>
                First, build the NXT project and upload it to the brick using leJOS NXJ Plug-in in Eclipse.
                <br>Only then build the PC project and run it. Upon running it will automaticlly connect to the NXT,
                and will be ready for operation.
            </p>

            <a name="architecture"><h4 class="midTitle">Project Architecture</h4></a>
            <p>
                Due to the fact that the color sensor read method (RGB mode) is not implemented in the PC mode of
                LeJOS, and on the other hand the algorithm cannot run in NXT mode due to insufficient memory,
                we divided the project to two applications.
                <br>We've implemented a communication between the PC application that's running the algorithm and
                the NXT application that performs all of the robot's operations including the unimplemented
                color sensor read operation.
            </p>

            <h5 style="text-decoration: underline">The Project is divided into the three following sub-projects:</h5>
            <a name="nxtProj"><h5>1) NXT Project</h5></a>
            <p>Running simple program waiting for commands from the PC application.</p>
            <a name="pcProj"><h5>2) PC Project</h5></a>
            <p>Main program of the project, the PC application. Responsible for the user interface, test methods,
                calibration methods and solving the cube.
            <br>This project is divided into the following main modules:
            <ul>
                <li>The Algorithm: receives the cube representation and calculates the required solving steps (to be
                    executed by the robot)
                </li>
                <li>The Cube: creating a Java class which holds the cube’s representation and relevant data (passed as
                    an input to the algorithm)
                </li>
                <li>The Robot: creating our own friendly API for scanning and manipulating the cube</li>
            </ul></p>
            <a name="utProj"><h5>3) Unit Test Project</h5></a>
            <p>This project contains all the projects' unit testing</p>

            <a name="reqAndAssump"><h4 class="midTitle">Requirements & Assumptions</h4></a>
            <ol>
                <li>The NXT robot was built according to the <a href="http://mindcuber.com/mindcuber/MindCuber.pdf">building instructions</a></li>
                <li>The robot's arm is at it's startup position before running the application (as in the attached videos above)</li>
                <li>The robot is calibrated (see <a href="#userGuide">User Guide</a>)</li>
                <li>The lighting conditions is stable during the robot's operation</li>
                <li>The Rubik's Cube is provided in a valid state (so that it is is guaranteed that a solution exists)</li>
            </ol>

            <a name="robotClass"></a>
                    <h4 class="midTitle">The Robot Class</h4>
                    
                    
                    <a name="actions"><h5>Actions</h5></a>
                    
                            <p>The Robot supports the following actions for the Cube's usage:</p>
                            <ul>
                                <li> Robot.flipCube(...)  &nbsp; &nbsp;  // performs 0, 1 or 2 Cube BackFlips as requested</li>
                                <li> Robot.rotateCube(...)&nbsp;         // performs Full Cube Rotations to the LEFT, RIGHT, or 180 degrees</li>
                                <li> Robot.turnFace(...)  &nbsp; &nbsp;  // Specific Cube Face Rotation to the LEFT, RIGHT, or 180 degrees</li>
                                <li> Robot.scanFace(...)  &nbsp; &nbsp;  // scans all colors in the given cube's face</li>
                                <li> More operations...</li>
                            </ul>

                            <p>Following is the 'flipCube' method, which flips the cube according to the flipMethod enum parameter -  SINGLE(1), DOUBLE(2), NONE(0):
                            <pre class="CodeBox"><code>
/**
 * Flip the cube
 *
 * @param method Flip method
 * @see FlipMethod
 */
public static void flipCube(FlipMethod method) {
    for (int i = 0; i < method.getFlips(); i++) {
        Arm.motor.rotateTo(ARM_POSITION_HOLD + ARM_POSITION_HOLD_EXTRA);
        Arm.motor.rotateTo(ARM_POSITION_HOLD);
        delayMillisec(ARM_FLIP_DELAY_MS);
        Arm.motor.rotateTo(ARM_POSITION_TACKLE);
        Arm.motor.rotateTo(ARM_POSITION_HOLD);
    }	
}
                            </code></pre></p>


                            <p>Following is the 'turnFace' method,
                                which turns the currently facing down face selected face according to the turning direction argument:
                            <pre class="CodeBox"><code>
/**
 * Rotate the face currently facing down
 *
 * @param direction Turning direction
 * @see Direction
 */
public static void turnFace(Direction direction) {
    Arm.motor.rotateTo(ARM_POSITION_HOLD);
    int extraRotation = direction.getDegree() > 0 ? 
                                        TRAY_MOTOR_EXTRA_ROTATION : (-TRAY_MOTOR_EXTRA_ROTATION);
    Tray.motor.rotate((direction.getDegree() + extraRotation) * TRAY_MOTOR_ROTATION_FACTOR);
    Tray.motor.rotate((-extraRotation) * TRAY_MOTOR_ROTATION_FACTOR);
}
                            </code></pre></p>

                            <p>Following is the 'rotateCube' method,
                                which Rotates the entire cube according to the direction argument:
                            <pre class="CodeBox" style="width: 400px"><code>
/**
 * Rotate entire cube
 *
 * @param direction Rotate direction
 * @see Direction
 */
public static void rotateCube(Direction direction) {
    if (direction != Direction.NONE) {
        Arm.release();
        Tray.rotate(direction.getDegree());
    }
}
                            </code></pre></p>


            <a name="colorScan"><h5>Color Scan</h5></a>
            <p>
                The NXT's color sensor is problematic and unreliable, so we needed to be creative in order to scan the
                cube.
                <br>Those are the phases of our color scanning development:
            <ol>
                <li>
                    We started with the ‘ReadColorId’ method supplied in LeJOS API.
                    We quickly understood that it cannot distinct between red and orange and therefore is useless.
                </li>
                <li>
                    Later on we've used the RGB representation reading of each color.
                    In order to utilize those readings, we've added calibration method that saves the RGB read of each
                    color
                    before starting solving the cube.
                    Then, when scanning the face and read RGB of some color, we've searched for the closest color with
                    the calibrated data we saved before.
                    But... we still had problems with red and orange colors!
                </li>
                <li>
                    Our next step was to develop color corrector method.
                    Since each of the cube's corners are deterministic, we can correct any red and orange mistakes in
                    the cube's corners by looking at their neighbors.
                    More about it can be learned below.
                    And yet it wasn't enough! We were on 70% success rate because we still had problems with red and
                    orange colors that are not on the corners...
                </li>
                <li>
                    SHIFT DELETE.
                    We needed to redesign the color reading method, we've decided to calculate the colors relatively.
                    First scan RGB colors of the whole cube.
                    Then, filter out all the white readings by their destination to the calibrated data (similar to step
                    2 above).
                    Last, converting the readings to HSV format, and sorting them by their hue value.
                    The first 9 lowest hue values are defined as red, the next 9 defined as orange, etc.
                    Now, under good lighting conditions we're on 99% success rate!
                </li>
            </ol>

            <p>Following is the method responsible for scanning single cube's face
            <pre class="CodeBox"><code>
/**
 * Scan cube's face
 * 
 * @param allColors List of all scanned colors 
 * @param orientation Current cube orientation
 * @see Orientation
 */
public static void scanFace(ArrayList<RawColor> allColors, Orientation orientation) {
    int coordinate, row, col;
    int[] rgb;
    SensorLocation location;
     
    Arm.release();
    for (coordinate = 0; coordinate < 8; coordinate++) {
        row = COORDINATE_SCAN_ORDER[coordinate][0];
        col = COORDINATE_SCAN_ORDER[coordinate][1];
        location = coordinate % 2 == 0 ? SensorLocation.ALIGN : SensorLocation.CORNER;
        ColorDetector.setMotorLocation(location);
        rgb = ColorDetector.sensor.readColorRgb(SENSOR_NUMBER_OF_SAMPLES);
        RawColor rawColor = new RawColor(orientation, row, col, rgb);
        allColors.add(rawColor);
        Tray.motor.rotate(TRAY_SCAN_STEP_DEGREE);
    }

    row = COORDINATE_SCAN_ORDER[coordinate][0];
    col = COORDINATE_SCAN_ORDER[coordinate][1];
    ColorDetector.setMotorLocation(SensorLocation.CENTER);
    rgb = ColorDetector.sensor.readColorRgb(SENSOR_NUMBER_OF_SAMPLES);
    RawColor rawColor = new RawColor(orientation, row, col, rgb);
    allColors.add(rawColor);
    ColorDetector.motor.rotateTo(0);
}
                            </code></pre></p>
                    
                            <p>Following is the method responsible for setting the cube's colors given
                            the raw readings of all the colors:
                            <pre class="CodeBox" style="width: 500px"><code>
/**
 * Place all scanned colors on the cube, fix red/orange corners
 * and print result to logger 
 * 
 * @param allColors All scanned colors
 */
private void calcAndSetColors(ArrayList<RawColor> allColors) {
    setWhitesByDistance(allColors);
    setNonWhitesByHue(allColors);
    ColorCorrector.fixCorners(faces);
    printCubeColorsToLogger();
}
                            </code></pre></p>
                    
                    
                    <a name="colorCorrector"><h5>The Color Corrector Class</h5></a><p>
                        <code><b>public class ColorCorrector</b></code><br>
                        An essential component in the process of solving a cube by robot,
                        is achieving a reliable image of the cube's colors. <br>
                        The ColorCorrector class is intended to do exactly that! It corrects color scanning errors
                        (which often occur due to the sensitive and unideal color sensors)
                        and provides a highly reliable description of the cube's colors (to be safely used by the algorithm).<br>
                        The NXT's color sensor has difficulties to distinguish between Red and Orange colors. <br>
                        Since we are able to determine the colors at each of the cube's corners by it's neighbors,
                        we can detect and correct any Red/Orange mix up at the corners.
                        This is how the class represents the corner:
                    <pre>
                             +--------+--------+
                             |        |        |
                             | corner | right  |
                             |        |        |
                             |        |        |
                             +--------+--------+
                             |        |
                             |  left  |
                             |        |
                             |        |
                             +--------+
                    </pre>
                    Whereas each of the squares above belong to another cube's face.
                    </p>
        <p>The following enumeration represent all corners of cube's face:</p>
        <pre class="CodeBox" style="width: 400px"><code>
private enum Corner {
    UPPER_LEFT(0, 0, 0),
    UPPER_RIGHT(1, 0, 2),
    LOWER_LEFT(2, 2, 0),
    LOWER_RIGHT(3, 2, 2);
}
        </code></pre>
                    <pre>
                          +--------+--------+--------+
                          |        |        |        |
                          | UPPER  |        | UPPER  |
                          | LEFT   |        | RIGHT  |
                          |        |        |        |
                          +--------+--------+--------+
                          |        |        |        |
                          |        |        |        |
                          |        |        |        |
                          |        |        |        |
                          +--------+--------+--------+
                          |        |        |        |
                          | LOWER  |        | LOWER  |
                          | LEFT   |        | RIGHT  |
                          |        |        |        |
                          +--------+--------+--------+
                    </pre>
                    <p>
                        The following 'fixCorners' method is responsible for the fix routine:<br>
                        Iterates over all the cube's Red/Orange corners and fix them according to their neighbors.
                    </p>
        <pre class="CodeBox"><code>
static void fixCorners(Face[] faces) {
    boolean cubeFixed = false;
    for (Orientation orientation : Orientation.values()) {
        Face face = faces[orientation.getValue()];

        for (Corner corner : Corner.values()) {
            if (face.getColor(corner.row, corner.col) == Colors.RED
                            || face.getColor(corner.row, corner.col) == Colors.ORANGE) {
                Colors left = getCornerLeftColor(faces, face, corner);
                Colors right = getCornerRightColor(faces, face, corner);

                for (Colors[] cornerColors : RED_ORANGE_CORNERS) {
                    if (left == cornerColors[0] && right == cornerColors[2]) {
                        Colors scannedColor = face.getColor(corner.row, corner.col);
                        Colors cornerColor = cornerColors[1];
                        if (scannedColor != cornerColor) {
                            face.setColor(corner.row, corner.col, cornerColor);
                        }
                    }
                }
            }
        }
    }
}
        </code></pre>

                            <a name="nxtComm"><h5>NXT Communication</h5></a><p>
                            As mentioned before, we needed to implement communication between the PC and NXT applications.
                            <br>We've simply wrapped all of the motors and sensors operations in the PC project, and send appropriate
                            command to the NXT application, that parsed the command and act upon it.

                            <p>For example, this is the implementation of the <code>rotateTo</code> method in the PC project:
                            <pre class="CodeBox" style="width: 840px"><code>
/**
 * Rotate motor to specified location
 * @param limitAngle Degrees limit to rotate
 */
public void rotateTo(int limitAngle) {
    NxtCommand.sendCommand(NxtOperation.OPERATION_TYPE_MOTOR, id, NxtOperation.OPERATION_ID_ROTATE_TO, limitAngle, 0);		
}
                            </code></pre></p>
                            
                            <p>This data sent as bytes to the NXT application. Upon receiving the raw bytes data,
                            the NXT application interprets and act upon it:
                            <pre class="CodeBox" style="width: 600px"><code>
/**
 * Run the main loop waiting for command from PC
 * This function exits upon pressing the ESC button on the NXT
 */
private static void runCommandListener() {

...

        for (;;) {
            try {
                if ((inputBufferLength = in.read(inputBuffer)) > 0) {
                    if (inputBufferLength != 7) {
                        printToLcd("Unknown data", "received", 10000);
                        continue;
                    }
                    printToLcd("Command recieved:", bytesToHex(inputBuffer), 0);
                    byte operationType = inputBuffer[0];
                    int port = (int) inputBuffer[1];
                    byte operationId = inputBuffer[2];

                    int argument = 0;
                    argument |= (((int) inputBuffer[3]) & 0x000000FF) << 24;
                    argument |= (((int) inputBuffer[4]) & 0x000000FF) << 16;
                    argument |= (((int) inputBuffer[5]) & 0x000000FF) << 8;
                    argument |= (((int) inputBuffer[6]) & 0x000000FF) << 0;

                    if (operationType == OPERATION_TYPE_MOTOR) {
                        switch (operationId) {
                        case OPERATION_ID_ROTATE:
                            motors[port].rotate(argument);
                            break;
                        case OPERATION_ID_ROTATE_TO:
                            motors[port].rotateTo(argument);
                            break;
                            
...                            
                            </code></pre></p>                     
                            
                            
            <a name="cubeClass"></a>
            <h4 class="midTitle">The Cube Class</h4>
            <img id="cubeAnim" style="padding-right: 200px" align="right" src="resources/cubeAnimation.gif">
            <p>
                Provides a smart and compact Cube object which holds the cube’s data: Faces, colors and
                orientations<br>
                Managing changes in the cube’s orientations caused by rotations and flips (performed by the robot)
            </p>

            <a name="middleMan"><h5>The Middle Man...</h5></a>
            <p>
                The Cube.java class acts as the "middle man" between the Robot and the Algorithm:
                <br>The main.java program creates the Cube object and passes it on to the Algorithm.
                <br>The algorithm utilizes the Cube's functionality to read the Cube's colors and manipulate the Cube's
                faces, while the Cube transforms these requests to Robot actions.
                <br>The advantage is the Cube's ability to keep track of the changing orientations whenever the Robot
                rotates and flips the Cube.
            </p>

            <a name="interfaces"><h5>Public Interfaces</h5></a>
            <p>The following 'ICube' and 'IFace' interfaces expose the public methods of the cube,
            <br>which provide a safe and efficient way to manipulate the cube while tracking state changes.</p>
            <p>The public methods were carefully planned to expose only the exact functionality required for the client (namely
                the Algorithm class)
                <br>while keeping things 'simple' as possible.</p>
<p>The IFace interface, which represents each of the six cube faces:
<pre class="CodeBox"><code>
public interface IFace {
   /*
    * Returns the color of a position (row, col) in a face
    */
    public Colors getColor(int i, int j);

    /*
     * Represents a turn of the face in a desired direction.
     * It uses the dynamic orientation and the actions table to derive
     * the number of flips and rotation needed in order to bring this face to the bottom.
     * after this face is brought to the bottom, it is turn in the desired direction.
     * @param direction The direction that the face should turn
     */
    public void turn(Direction direction);
}
</code></pre></p>
<p>The ICube interface, which represents the entire cube:
<pre class="CodeBox"><code>
public interface ICube {
/*
 * returns the face which is currently in the orientation requested (UP, DOWN, LEFT, ...)
 */
IFace getFace(Orientation orientation);

/*
 * Scan and set the cube colors.
 * The method is first to scan all of the cube's colors in RGB mode,
 * and calculate their HSV representation as well as their distance from
 * the calibrated white RGB.
 * Second, sort all the colors by their white distance (since white doesn't have
 * meaningful Hue value), and place them on the cube.
 * Last, sort all the colors by their Hue value and place them on the cube
 * according to their Hue value.
 */
void setColors();

}
</code></pre></p>


            <a name="representation"><h5>Cube Representation</h5></a>
            <p>
                The Cube object is the representation of the Rubik's Cube as provided to the Algorithm class
                for calculating the required steps to reach a full solution.<br>
                A Cube object is consisted of six Face objects, where each one provides the functionality of a 'face turn'
                as well as the option of reading all face's colors.<br>
                One of the interesting challenges regarding the manipulations of the cube,
                arises from the fact that the robot can only rotate the bottom cube's face (placed on it's tray),
                while the algorithm may instruct to turn any of the cube's faces at each step.
                As consequence, the Robot often flips and rotates the whole cube in order to position the selected face
                as the bottom face.
                To bridge this gap, we let the algorithm act as if the cube is static (initial orientations never change),
                while translating each 'static' face orientation selection (Up, Down, etc.) to the 'dynamic' actual
                orientation of the selected face.<br>
                This process is implemented efficiently by the Cube class, by using an Orientations matrix and an Actions array
                which help keeping track of the 'dynamic' orientation of each of the cube's faces.
            </p>

            <a name="orientations"><h5>Cube Orientations</h5></a>
            <br><img width="200" src="./resources/rubikFlat.png"><br>

<p>The Orientations Matrix:
    <br> Following every rotation and flip of the cube executed by the robot, the cube's orientations change (i.e. 'UP' face may become 'DOWN', etc.)
    <br> The Orientations Matrix is a static matrix which represent the new position of every face
    <br> once any face is set to be the bottom face ('DOWN' orientation).
    <br> The faces are listed in the following order: 0 = Up, 1 = Right, 2 = Front, 3 = Down, 4 = Left, 5 = Back
    <br> <u>Example of use:</u>
    <br> Suppose we need to set the current 'FRONT' face to be the bottom ('DOWN') face,
    <br> in order to know how this action affects the other faces, we should go to the 2nd row of
    <br> the matrix (as listed above: 2 = FRONT), and we will find the new positions of the other faces:
    <br> position 0 has the value L -> indicates that the UP face (0 = UP) becomes the LEFT face.
    <br> position 1 has the value F -> indicates that the RIGHT face (1 = RIGHT) becomes the FRONT face, etc.
    <br> in conclusion we got these transforms: U->L , R->F , F->D , D->R, L->B , B->U
    <br> this matrix help us to determine the positions of the faces in any transition.
<pre class="CodeBox"><code>
private static final Orientation[][] ORIENTATION_MAT = {
{ Orientation.D, Orientation.L, Orientation.F, Orientation.U, Orientation.R, Orientation.B },
{ Orientation.L, Orientation.D, Orientation.B, Orientation.R, Orientation.U, Orientation.F },
{ Orientation.L, Orientation.F, Orientation.D, Orientation.R, Orientation.B, Orientation.U },
{ Orientation.U, Orientation.R, Orientation.F, Orientation.D, Orientation.L, Orientation.B },
{ Orientation.L, Orientation.U, Orientation.F, Orientation.R, Orientation.D, Orientation.B },
{ Orientation.L, Orientation.B, Orientation.U, Orientation.R, Orientation.F, Orientation.D } };
</code></pre></p>

            <p>
                Thanks to the 'Orientations Matrix' the routine of updating the new orientations of the faces after
                a transition of the cube, becomes a simple quick task -
                <br>The following method receives the current orientation of the face that was just set to the bottom,
                and performs required orientations updates to all six faces:
<pre class="CodeBox"><code>
void updateOrientations(Orientation orientation) {
Orientation[] newOrientations = ORIENTATION_MAT[orientation.getValue()];
    for (int i = 0; i < 6; i++) {
        faces[i].dynamicOrientation = newOrientations[faces[i].dynamicOrientation.getValue()];
    }
}
</code></pre></p>

            <p>The Action class, holds the required cube flips and turns
    to set a selected face as the bottom face:
<pre class="CodeBox"><code>
public class Action {

    public FlipMethod flips;
    public Direction direction;

    public Action(FlipMethod flips, Direction direction) {
    this.flips = flips;
    this.direction = direction;
    }
}
</code></pre></p>

<p>The 'Actions' Array:<br>
    specifies the flips and rotations that the robot should execute on the cube,
    to set the selected face as the bottom face (the only face that can be turned):
    <br>For instance, in order to turn the 'UP' face by 90 degrees clockwise, the Robot must first flip the cube twice
    to set the 'UP' face as the bottom, and then turn the face by 90 degrees counterclockwise.
    <br> Another example: in order to set the FRONT face as the bottom,
    the Robot should rotate the cube left and then perform a flip.
    <br>This action is stored on the actions array at position 2 (since 2 = FRONT): {FlipMethod.SINGLE, Direction.LEFT}
<pre class="CodeBox"><code>
actions[Orientation.U.getValue()] = new Action(FlipMethod.DOUBLE, Direction.NONE);
actions[Orientation.D.getValue()] = new Action(FlipMethod.NONE, Direction.NONE);
actions[Orientation.F.getValue()] = new Action(FlipMethod.SINGLE, Direction.LEFT);
actions[Orientation.B.getValue()] = new Action(FlipMethod.SINGLE, Direction.RIGHT);
actions[Orientation.R.getValue()] = new Action(FlipMethod.SINGLE, Direction.MIRROR);
actions[Orientation.L.getValue()] = new Action(FlipMethod.SINGLE, Direction.NONE);
</code></pre></p>



            <a name="algorithm"></a>
            <h4 class="midTitle">The Solving Algorithm</h4>
            <a name="choosingAlgo"><h5>Choosing the algorithm</h5></a>
            <p>
                At the beginning of the project, we devoted a considerable amount of time for exploring alternatives
                for the Rubik's cube solving algorithm - this includes research of existing algorithms as well as ideas
                for an original solution.
                We decided to go for a solution that will allow us to inject the full code into the robot
                to achieve an autonomous cube solver.
            </p>
            <p>Therefore, When exploring the alternatives, we examined each algorithm in terms of resource consumption and complexity:</p>
            <ul>
                <li>Memory required during the entire program run</li>
                <li>The complexity of the calculations and the processing time required</li>
                <li>The difficulty in implementing the code</li>
                <li>Overall runtime</li>
                <li>And more...</li>
            </ul>
            <p>Finally, the presented considerations and research led us to choosing the well known two-phase algorithm.</p>
            <a name="twoPhaseAlgo"><h5>2-Phase Algorithm</h5></a>
			<img id="imgHerbertKociemba" src="https://www.speedsolving.com/interviews/interview-herbertk.jpg">
            <p>
				We are using the two-phase algorithm, introduced by Herbert Kociemba in 1991-1992.
				The problem of solving the cube is translated into a shortest path in a graph problem, where the nodes are the different states of the cube,
				and there is an edge between two nodes if one state can be reached from the other by turning one face of the cube.
				Exploring and understanding the algorithm was one of the major parts of our project, and we believe it was quite educational (and most definitely fun :)).
            </p>
            <a name="solution"><h5>Searching For Solution</h5></a>
            <p>Searching for the solution is done in two phases:</p>
            <ol>
                <li>The algorithm first tries to find a path from cube’s initial state to one of the states that can be reached
                    from a solved cube using only the following moves: U, D, R2, L2 F2, B2.
                </li>
                <li>Once we found a path, the algorithm tries to find a path from the current state to the solved cube,
                    using only the moves mentioned above.
                </li>
            </ol>
            <p>
                The path search in the graph is done using the IDA* algorithm. Finding a shortest path in a graph can be
                done using a BFS-like tree search, but it requires a lot of memory. Using DFS-like tree search will help
                us finding a path, but not the shortest one. Therefore, the two-phase algorithm uses an iterative
                deepening search. Iterative deepening (ID) means a DFS search is performed iteratively for a growing
                tree depth. The search uses a heuristic function to stop searching in a specific branch when the
                solution cannot be found with the given state and depth. The heuristic function gives a lower bound on
                the number of moves required to reach from a state to the goal state.
            </p>
            <a name="algoRep"><h5>Cube Representation</h5></a>
            <p>
                Cube is represented in 3 levels:
				<br><b> Facelets Level </b> - cube is represented by an 54 entries array. Each entry is one of the 6 possibe colors of cube faces.
				This is the initial, most simple representation.
				<br><b> Cubie Level </b> - cube is represented by it's corners and edges permutations and orientations, compared to a solved cube.
				This representation tells us where to move and how to rotate each corner and where to move and how to flip each edge in order to reach a given cube from a solved cube.
				Using this representation, we can define the inverse cube of a cube, which is a cube that if we perform the set of moves created it from a solved cube on the original cube, we reach the solved cube.
				We can also define a multiplication of two cubes. You can think of multiplying cube A by cube B like taking a set of moves that transform a solved cube into B cube and perform it on A.
				<br><b> Coordinate Level </b> - cube is represented using a set of coordinates driven from it's corners and edges permutations and orientations compared to a solve cube.
				The set of coordinates is not the same in both phases. This set of coordinates defines us the state of the cube, which is used during the search algorithm.
            </p>
			<p>For more information regarding the two-phase algorithm, please refer to Kociemba’s site: <a href="http://kociemba.org/cube.htm">http://kociemba.org/cube.htm</a></p>
            <a name="implementation"><h5>The Implementation</h5></a>
            <p>
                Our implementation is based on Kociemba’s implementation for this algorithm, which he published in his site.
                It implements the two-phase algorithm in a simple form, and does not use symmetry for better performance.
				Moreover, the implementation does not find the shortest solution.
                It finds a short solution for the first phase, and then tries to find a short solution from current state
                to the solved cube, so the combination of the two is not necessarily the shortest solution.
            </p>

            <a name="modifications"><h5>Our Modifications</h5></a>
            <p>We added the ability to select a pattern, so that preforming the set of moves returned by the
                algorithm will produce a cube with the selected pattern.
                To allow the pattern ability, we calculate the inverse cube of the pattern, multiply it by the given
                cube and then find a solution for the resulted cube.
                The algorithm finds a solution for the resulted cube, which is also a set
                of moves to create its reverse cube from a solved cube. This reverse cube is the multiplication of the
                reverse of the original cube and the pattern, so applying the resulted set of moves on the cube brings
                us from the initial cube to a solved cube and then to the patterned cube (this is not done one after the
                other, this is just an easier way to understand what happens).
            </p>

            <a name="tests"></a>
            <h4 class="midTitle">Tests</h4><p>
            <h5>Unit Tests</h5>
			<p>
				We used the Junit framework for unit testing. All unit tests are found in the MindCuber_UT project.
				<br>Since most of our logic in the project containd in the algorithm module, we've put our best efforts testing it using unit tests, and indeed we've reached 96.8% coverage rate!
			</p>
			<p>
				Algorithms tests are found under the twophase package. There is a seperate test class for each of the 3 cube representations classes: CoordCubeTest, CubieCubeTest and FaceCubeTest.
				We tested classes constructors, properties and methods. This includes coordinate calculations, cube operations such as multiply and inverse, translations from one representation to another, cube validation etch.
				In the CoordCube test, we checked the creation of the all the static arrays that are used in the algorithm. We used Kociemba website and other examples to calculate the expcted results.
				We also tested the main function that finds a solution, for both valid and invalid cube, with and without pattern supplied. This is done in SearchTest class.
			</p>
			<p>
				Cube class tests are found under the cube package.
				<br>Under the application package you can find tests for the conversion between cube and algorithm representation.
				<br>The different tests are documented in each test class.
				In most tests, we used text files which contain the inputs and expected results. These files can be found under testsFiles. This allows adding more inputs without changing the code.
			</p>
			<p>
				To run the tests, open the MindCuber_UT project using eclipse, right click on the project and choose Run As..->Junit (Or click the Run button in the menu bar)
			</p>

            <a name="intgTest"><h5>Validation Tests</h5></a>
            <p>
                    Since the robot module is mostly an API we've decided to focus on validation tests.
                    <p>To check the robot reliability and robustness we've developed an over-night test that performs 100
                    cube solving operations and validates the cube after each operation.
                    <br>Those tests helped up caught and fix rare exceptions. In addition it helped 
                    us optimized some parameters and increase our success rate.
                    <br>In the last tests' cycle we've reached 98% success rate! (98 successes out of 100 tries)          
            <a name="userGuide"></a>
            <h4 class="midTitle">User Guide</h4><p>
            
                    <a name="pcApp"><h5>PC Application</h5></a><p>
                    <p><img class="robotMenu" src="./resources/mainmenu.jpg"><p>

                        <ul>
                            <li><b>Solve cube:</b>
                                    <br>Use this option after completing necessary calibration steps for solving the cube
                            </li><p>
                            
                            <li><b>Tests:</b>
                                <p><img class="robotMenu" src="./resources/testsmenu.jpg"><p>
                                This menu contains all of the robot's tests recommended to run to validate all robot's operations:
                                <ul>
                                        <li>Brute force - performs random robot's operations</li>
                                        <li>Read color - read current color and print result to logger</li>
                                        <li>Flip cube - performs cube flipping operations</li>
                                </ul>
                            </li><p>
                            
                            <li><b>Calibration:</b>
                                <p><img class="robotMenu" src="./resources/calibrationmenu.jpg"><p>
                                This menu contains all of the robot's calibration routines:
                                <ul>
                                        <li>Color sensor - calibrate white color reading, place white color below the sensor and press <b>Enter</b></li>
                                        <li>Color motor - calibrate the color sensor motor. Follow the instructions of the program to calibrate the color sensor to it's three optional positions. Use the <b><</b> and <b>></b> buttons to rotate the motor</li>
                                        <li>Cube tray - calibrate the cube's tray motor. Use the <b><</b> and <b>></b> buttons to rotate the tray to be aligned</li>
                                        <li>Proximity - read the current proximity sensor data</li>
                                        <li>
                                                Color light - read the current background light. Use it to make sure the lighting condition of the room are suitable for the color sensor:<p>
                                                <ul>
                                                        <li>Light okay:<p><img  src="./resources/background_ok.jpg"><p></li>
                                                        <li>Light too strong<p><img  src="./resources/background_not.jpg"><p></li>
                                                </ul>
                                        </li>
                                </ul>
                                
                            </li><p>
                            
                            <li><b>Pattern:</b>
                                <p><img class="robotMenu" src="./resources/patternmenu.jpg"><p>
                                This menu contains additional patterns for cube solving:
                                <ul>
                                        <li>Plus minus</li>
                                        <li>4 cross</li>
                                        <li>Cube cube</li>
                                        <li>Cube cube cube</li>
                                </ul>
                            </li><p>
                            
                        </ul>
                                

            <a name="generalRemarks"></a>
            <h4 class="midTitle">General Remarks</h4>
            <p>The described project was carried out as part of the "Models in Software Engineering" Workshop led by Dr. Shahar Maoz, Tel Aviv University CS School.</p>
            <p>Development team members: Nerya Meshulam, Gil Akiva, Nir Zaidman, Elad Yacobi and Ofek Amir.</p>
            <img width="600" src="./resources/team.jpg">

            <a name="gallery"></a>
            <h4 class="midTitle">Gallery</h4>
            <TODO>In Renovations...</TODO>
            <br><br><img width="400" src="./resources/RubiksVariations.jpg"><br>

        </td>
        </tr>
        </tbody>
    </table>
</div>
</body>
</html>
